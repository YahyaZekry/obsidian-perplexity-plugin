<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perplexity Vault Assistant - Obsidian Plugin</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232563eb'><path d='M20 6L9 17l-5-5'/></svg>">
    <style>
        /* Perplexity Design System */
        :root {
          /* Primitive Color Tokens */
          --color-white: rgba(255, 255, 255, 1);
          --color-black: rgba(0, 0, 0, 1);
          --color-cream-50: rgba(252, 252, 249, 1);
          --color-cream-100: rgba(255, 255, 253, 1);
          --color-gray-200: rgba(245, 245, 245, 1);
          --color-gray-300: rgba(167, 169, 169, 1);
          --color-gray-400: rgba(119, 124, 124, 1);
          --color-slate-500: rgba(98, 108, 113, 1);
          --color-brown-600: rgba(94, 82, 64, 1);
          --color-charcoal-700: rgba(31, 33, 33, 1);
          --color-charcoal-800: rgba(38, 40, 40, 1);
          --color-slate-900: rgba(19, 52, 59, 1);
          --color-teal-300: rgba(50, 184, 198, 1);
          --color-teal-400: rgba(45, 166, 178, 1);
          --color-teal-500: rgba(33, 128, 141, 1);
          --color-teal-600: rgba(29, 116, 128, 1);
          --color-teal-700: rgba(26, 104, 115, 1);
          --color-teal-800: rgba(41, 150, 161, 1);
          --color-red-400: rgba(255, 84, 89, 1);
          --color-red-500: rgba(192, 21, 47, 1);
          --color-orange-400: rgba(230, 129, 97, 1);
          --color-orange-500: rgba(168, 75, 47, 1);

          /* RGB versions for opacity control */
          --color-brown-600-rgb: 94, 82, 64;
          --color-teal-500-rgb: 33, 128, 141;
          --color-slate-900-rgb: 19, 52, 59;
          --color-slate-500-rgb: 98, 108, 113;
          --color-red-500-rgb: 192, 21, 47;
          --color-red-400-rgb: 255, 84, 89;
          --color-orange-500-rgb: 168, 75, 47;
          --color-orange-400-rgb: 230, 129, 97;

          /* Background color tokens (Light Mode) */
          --color-bg-1: rgba(59, 130, 246, 0.08);
          --color-bg-2: rgba(245, 158, 11, 0.08);
          --color-bg-3: rgba(34, 197, 94, 0.08);
          --color-bg-4: rgba(239, 68, 68, 0.08);
          --color-bg-5: rgba(147, 51, 234, 0.08);
          --color-bg-6: rgba(249, 115, 22, 0.08);
          --color-bg-7: rgba(236, 72, 153, 0.08);
          --color-bg-8: rgba(6, 182, 212, 0.08);

          /* Semantic Color Tokens (Light Mode) */
          --color-background: var(--color-cream-50);
          --color-surface: var(--color-cream-100);
          --color-text: var(--color-slate-900);
          --color-text-secondary: var(--color-slate-500);
          --color-primary: var(--color-teal-500);
          --color-primary-hover: var(--color-teal-600);
          --color-primary-active: var(--color-teal-700);
          --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
          --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
          --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
          --color-border: rgba(var(--color-brown-600-rgb), 0.2);
          --color-btn-primary-text: var(--color-cream-50);
          --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
          --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
          --color-error: var(--color-red-500);
          --color-success: var(--color-teal-500);
          --color-warning: var(--color-orange-500);
          --color-info: var(--color-slate-500);
          --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
          --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

          /* Common style patterns */
          --focus-ring: 0 0 0 3px var(--color-focus-ring);
          --focus-outline: 2px solid var(--color-primary);
          --status-bg-opacity: 0.15;
          --status-border-opacity: 0.25;
          --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
          --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

          /* RGB versions for opacity control */
          --color-success-rgb: 33, 128, 141;
          --color-error-rgb: 192, 21, 47;
          --color-warning-rgb: 168, 75, 47;
          --color-info-rgb: 98, 108, 113;

          /* Typography */
          --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system,
            BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo,
            Monaco, Consolas, monospace;
          --font-size-xs: 11px;
          --font-size-sm: 12px;
          --font-size-base: 14px;
          --font-size-md: 14px;
          --font-size-lg: 16px;
          --font-size-xl: 18px;
          --font-size-2xl: 20px;
          --font-size-3xl: 24px;
          --font-size-4xl: 30px;
          --font-weight-normal: 400;
          --font-weight-medium: 500;
          --font-weight-semibold: 550;
          --font-weight-bold: 600;
          --line-height-tight: 1.2;
          --line-height-normal: 1.5;
          --letter-spacing-tight: -0.01em;

          /* Spacing */
          --space-0: 0;
          --space-1: 1px;
          --space-2: 2px;
          --space-4: 4px;
          --space-6: 6px;
          --space-8: 8px;
          --space-10: 10px;
          --space-12: 12px;
          --space-16: 16px;
          --space-20: 20px;
          --space-24: 24px;
          --space-32: 32px;

          /* Border Radius */
          --radius-sm: 6px;
          --radius-base: 8px;
          --radius-md: 10px;
          --radius-lg: 12px;
          --radius-full: 9999px;

          /* Shadows */
          --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
          --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
          --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04),
            0 2px 4px -1px rgba(0, 0, 0, 0.02);
          --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04),
            0 4px 6px -2px rgba(0, 0, 0, 0.02);
          --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15),
            inset 0 -1px 0 rgba(0, 0, 0, 0.03);

          /* Animation */
          --duration-fast: 150ms;
          --duration-normal: 250ms;
          --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

          /* Layout */
          --container-sm: 640px;
          --container-md: 768px;
          --container-lg: 1024px;
          --container-xl: 1280px;
        }

        /* Dark mode colors */
        @media (prefers-color-scheme: dark) {
          :root {
            /* RGB versions for opacity control (Dark Mode) */
            --color-gray-400-rgb: 119, 124, 124;
            --color-teal-300-rgb: 50, 184, 198;
            --color-gray-300-rgb: 167, 169, 169;
            --color-gray-200-rgb: 245, 245, 245;

            /* Background color tokens (Dark Mode) */
            --color-bg-1: rgba(29, 78, 216, 0.15);
            --color-bg-2: rgba(180, 83, 9, 0.15);
            --color-bg-3: rgba(21, 128, 61, 0.15);
            --color-bg-4: rgba(185, 28, 28, 0.15);
            --color-bg-5: rgba(107, 33, 168, 0.15);
            --color-bg-6: rgba(194, 65, 12, 0.15);
            --color-bg-7: rgba(190, 24, 93, 0.15);
            --color-bg-8: rgba(8, 145, 178, 0.15);

            /* Semantic Color Tokens (Dark Mode) */
            --color-background: var(--color-charcoal-700);
            --color-surface: var(--color-charcoal-800);
            --color-text: var(--color-gray-200);
            --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
            --color-primary: var(--color-teal-300);
            --color-primary-hover: var(--color-teal-400);
            --color-primary-active: var(--color-teal-800);
            --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
            --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
            --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
            --color-border: rgba(var(--color-gray-400-rgb), 0.3);
            --color-error: var(--color-red-400);
            --color-success: var(--color-teal-300);
            --color-warning: var(--color-orange-400);
            --color-info: var(--color-gray-300);
            --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
            --color-btn-primary-text: var(--color-slate-900);
            --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
            --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
            --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
              inset 0 -1px 0 rgba(0, 0, 0, 0.15);
            --button-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
            --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
            --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

            /* RGB versions for dark mode */
            --color-success-rgb: var(--color-teal-300-rgb);
            --color-error-rgb: var(--color-red-400-rgb);
            --color-warning-rgb: var(--color-orange-400-rgb);
            --color-info-rgb: var(--color-gray-300-rgb);
          }
        }

        /* Base styles */
        html {
          font-size: var(--font-size-base);
          font-family: var(--font-family-base);
          line-height: var(--line-height-normal);
          color: var(--color-text);
          background-color: var(--color-background);
          -webkit-font-smoothing: antialiased;
          box-sizing: border-box;
        }

        body {
          margin: 0;
          padding: 0;
          min-height: 100vh;
        }

        *,
        *::before,
        *::after {
          box-sizing: inherit;
        }

        /* Typography */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
          margin: 0;
          font-weight: var(--font-weight-semibold);
          line-height: var(--line-height-tight);
          color: var(--color-text);
          letter-spacing: var(--letter-spacing-tight);
        }

        h1 {
          font-size: var(--font-size-4xl);
        }
        h2 {
          font-size: var(--font-size-3xl);
        }
        h3 {
          font-size: var(--font-size-2xl);
        }
        h4 {
          font-size: var(--font-size-xl);
        }
        h5 {
          font-size: var(--font-size-lg);
        }
        h6 {
          font-size: var(--font-size-md);
        }

        p {
          margin: 0 0 var(--space-16) 0;
        }

        a {
          color: var(--color-primary);
          text-decoration: none;
          transition: color var(--duration-fast) var(--ease-standard);
        }

        a:hover {
          color: var(--color-primary-hover);
        }

        code,
        pre {
          font-family: var(--font-family-mono);
          font-size: calc(var(--font-size-base) * 0.95);
          background-color: var(--color-secondary);
          border-radius: var(--radius-sm);
        }

        code {
          padding: var(--space-1) var(--space-4);
        }

        pre {
          padding: var(--space-16);
          margin: var(--space-16) 0;
          overflow: auto;
          border: 1px solid var(--color-border);
        }

        pre code {
          background: none;
          padding: 0;
        }

        /* Buttons */
        .btn {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          padding: var(--space-8) var(--space-16);
          border-radius: var(--radius-base);
          font-size: var(--font-size-base);
          font-weight: 500;
          line-height: 1.5;
          cursor: pointer;
          transition: all var(--duration-normal) var(--ease-standard);
          border: none;
          text-decoration: none;
          position: relative;
        }

        .btn:focus-visible {
          outline: none;
          box-shadow: var(--focus-ring);
        }

        .btn--primary {
          background: var(--color-primary);
          color: var(--color-btn-primary-text);
        }

        .btn--primary:hover {
          background: var(--color-primary-hover);
        }

        .btn--primary:active {
          background: var(--color-primary-active);
        }

        .btn--secondary {
          background: var(--color-secondary);
          color: var(--color-text);
        }

        .btn--secondary:hover {
          background: var(--color-secondary-hover);
        }

        .btn--secondary:active {
          background: var(--color-secondary-active);
        }

        .btn--outline {
          background: transparent;
          border: 1px solid var(--color-border);
          color: var(--color-text);
        }

        .btn--outline:hover {
          background: var(--color-secondary);
        }

        .btn--sm {
          padding: var(--space-4) var(--space-12);
          font-size: var(--font-size-sm);
          border-radius: var(--radius-sm);
        }

        .btn--lg {
          padding: var(--space-10) var(--space-20);
          font-size: var(--font-size-lg);
          border-radius: var(--radius-md);
        }

        .btn--full-width {
          width: 100%;
        }

        .btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        /* Form elements */
        .form-control {
          display: block;
          width: 100%;
          padding: var(--space-8) var(--space-12);
          font-size: var(--font-size-md);
          line-height: 1.5;
          color: var(--color-text);
          background-color: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: var(--radius-base);
          transition: border-color var(--duration-fast) var(--ease-standard),
            box-shadow var(--duration-fast) var(--ease-standard);
        }

        textarea.form-control {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

        select.form-control {
          padding: var(--space-8) var(--space-12);
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          background-image: var(--select-caret-light);
          background-repeat: no-repeat;
          background-position: right var(--space-12) center;
          background-size: 16px;
          padding-right: var(--space-32);
        }

        @media (prefers-color-scheme: dark) {
          select.form-control {
            background-image: var(--select-caret-dark);
          }
        }

        .form-control:focus {
          border-color: var(--color-primary);
          outline: var(--focus-outline);
        }

        .form-label {
          display: block;
          margin-bottom: var(--space-8);
          font-weight: var(--font-weight-medium);
          font-size: var(--font-size-sm);
        }

        .form-group {
          margin-bottom: var(--space-16);
        }

        /* Card component */
        .card {
          background-color: var(--color-surface);
          border-radius: var(--radius-lg);
          border: 1px solid var(--color-card-border);
          box-shadow: var(--shadow-sm);
          overflow: hidden;
          transition: box-shadow var(--duration-normal) var(--ease-standard);
        }

        .card:hover {
          box-shadow: var(--shadow-md);
        }

        .card__body {
          padding: var(--space-16);
        }

        .card__header,
        .card__footer {
          padding: var(--space-16);
          border-bottom: 1px solid var(--color-card-border-inner);
        }

        /* Status indicators */
        .status {
          display: inline-flex;
          align-items: center;
          padding: var(--space-6) var(--space-12);
          border-radius: var(--radius-full);
          font-weight: var(--font-weight-medium);
          font-size: var(--font-size-sm);
        }

        .status--success {
          background-color: rgba(
            var(--color-success-rgb, 33, 128, 141),
            var(--status-bg-opacity)
          );
          color: var(--color-success);
          border: 1px solid
            rgba(var(--color-success-rgb, 33, 128, 141), var(--status-border-opacity));
        }

        .status--error {
          background-color: rgba(
            var(--color-error-rgb, 192, 21, 47),
            var(--status-bg-opacity)
          );
          color: var(--color-error);
          border: 1px solid
            rgba(var(--color-error-rgb, 192, 21, 47), var(--status-border-opacity));
        }

        .status--warning {
          background-color: rgba(
            var(--color-warning-rgb, 168, 75, 47),
            var(--status-bg-opacity)
          );
          color: var(--color-warning);
          border: 1px solid
            rgba(var(--color-warning-rgb, 168, 75, 47), var(--status-border-opacity));
        }

        .status--info {
          background-color: rgba(
            var(--color-info-rgb, 98, 108, 113),
            var(--status-bg-opacity)
          );
          color: var(--color-info);
          border: 1px solid
            rgba(var(--color-info-rgb, 98, 108, 113), var(--status-border-opacity));
        }

        /* Container layout */
        .container {
          width: 100%;
          margin-right: auto;
          margin-left: auto;
          padding-right: var(--space-16);
          padding-left: var(--space-16);
        }

        @media (min-width: 640px) {
          .container {
            max-width: var(--container-sm);
          }
        }
        @media (min-width: 768px) {
          .container {
            max-width: var(--container-md);
          }
        }
        @media (min-width: 1024px) {
          .container {
            max-width: var(--container-lg);
          }
        }
        @media (min-width: 1280px) {
          .container {
            max-width: var(--container-xl);
          }
        }

        /* Utility classes */
        .flex {
          display: flex;
        }
        .flex-col {
          flex-direction: column;
        }
        .items-center {
          align-items: center;
        }
        .justify-center {
          justify-content: center;
        }
        .justify-between {
          justify-content: space-between;
        }
        .gap-4 {
          gap: var(--space-4);
        }
        .gap-8 {
          gap: var(--space-8);
        }
        .gap-16 {
          gap: var(--space-16);
        }

        .m-0 {
          margin: 0;
        }
        .mt-8 {
          margin-top: var(--space-8);
        }
        .mb-8 {
          margin-bottom: var(--space-8);
        }
        .mx-8 {
          margin-left: var(--space-8);
          margin-right: var(--space-8);
        }
        .my-8 {
          margin-top: var(--space-8);
          margin-bottom: var(--space-8);
        }

        .p-0 {
          padding: 0;
        }
        .py-8 {
          padding-top: var(--space-8);
          padding-bottom: var(--space-8);
        }
        .px-8 {
          padding-left: var(--space-8);
          padding-right: var(--space-8);
        }
        .py-16 {
          padding-top: var(--space-16);
          padding-bottom: var(--space-16);
        }
        .px-16 {
          padding-left: var(--space-16);
          padding-right: var(--space-16);
        }

        .block {
          display: block;
        }
        .hidden {
          display: none;
        }

        /* Accessibility */
        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border-width: 0;
        }

        :focus-visible {
          outline: var(--focus-outline);
          outline-offset: 2px;
        }

        @font-face {
          font-family: 'FKGroteskNeue';
          src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2')
            format('woff2');
        }

        /* Custom styles for this application */
        .header {
          background: var(--color-surface);
          border-bottom: 1px solid var(--color-border);
          padding: var(--space-16) 0;
          margin-bottom: var(--space-32);
        }

        .main-content {
          max-width: 1200px;
          margin: 0 auto;
          padding: 0 var(--space-16);
        }

        .feature-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: var(--space-24);
          margin-bottom: var(--space-32);
        }

        .feature-card {
          padding: var(--space-24);
          text-align: center;
        }

        .feature-icon {
          width: 48px;
          height: 48px;
          margin: 0 auto var(--space-16) auto;
          background: var(--color-bg-1);
          border-radius: var(--radius-lg);
          display: flex;
          align-items: center;
          justify-content: center;
          color: var(--color-primary);
        }

        .feature-card h3 {
          margin-bottom: var(--space-8);
        }

        .feature-card p {
          color: var(--color-text-secondary);
          margin-bottom: var(--space-16);
        }

        .code-block {
          background: var(--color-surface);
          border: 1px solid var(--color-border);
          border-radius: var(--radius-base);
          padding: var(--space-16);
          margin: var(--space-16) 0;
          overflow-x: auto;
        }

        .file-structure {
          font-family: var(--font-family-mono);
          font-size: var(--font-size-sm);
          line-height: 1.6;
        }

        .file-structure .folder {
          font-weight: var(--font-weight-medium);
          color: var(--color-primary);
        }

        .file-structure .file {
          color: var(--color-text-secondary);
        }

        .installation-steps {
          background: var(--color-bg-2);
          border-radius: var(--radius-lg);
          padding: var(--space-24);
          margin: var(--space-24) 0;
        }

        .step {
          display: flex;
          align-items: flex-start;
          margin-bottom: var(--space-16);
        }

        .step:last-child {
          margin-bottom: 0;
        }

        .step-number {
          background: var(--color-primary);
          color: var(--color-btn-primary-text);
          width: 24px;
          height: 24px;
          border-radius: var(--radius-full);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: var(--font-size-sm);
          font-weight: var(--font-weight-medium);
          margin-right: var(--space-12);
          flex-shrink: 0;
        }

        .step-content {
          flex: 1;
        }

        .step h4 {
          margin-bottom: var(--space-4);
        }

        .step p {
          color: var(--color-text-secondary);
          margin: 0;
        }

        .api-info {
          background: var(--color-bg-3);
          border-radius: var(--radius-lg);
          padding: var(--space-20);
          margin: var(--space-24) 0;
        }

        .api-info h4 {
          display: flex;
          align-items: center;
          gap: var(--space-8);
          margin-bottom: var(--space-12);
        }

        .warning-icon {
          color: var(--color-warning);
        }

        .footer {
          background: var(--color-surface);
          border-top: 1px solid var(--color-border);
          padding: var(--space-32) 0;
          margin-top: var(--space-32);
          text-align: center;
        }

        .footer p {
          color: var(--color-text-secondary);
          margin: 0;
        }

        .tech-stack {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-8);
          margin: var(--space-16) 0;
        }

        .tech-tag {
          background: var(--color-secondary);
          color: var(--color-text);
          padding: var(--space-4) var(--space-8);
          border-radius: var(--radius-full);
          font-size: var(--font-size-xs);
          font-weight: var(--font-weight-medium);
        }

        .download-section {
          text-align: center;
          background: var(--color-bg-4);
          border-radius: var(--radius-lg);
          padding: var(--space-32);
          margin: var(--space-32) 0;
        }

        .download-section h3 {
          margin-bottom: var(--space-16);
        }

        .download-buttons {
          display: flex;
          gap: var(--space-16);
          justify-content: center;
          flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <h1>Perplexity Vault Assistant</h1>
            <p class="m-0" style="color: var(--color-text-secondary);">AI-powered Obsidian plugin for vault management, spell checking, and smart linking</p>
        </div>
    </header>

    <main class="main-content">
        <!-- Features Section -->
        <section>
            <h2 style="text-align: center; margin-bottom: var(--space-32);">Key Features</h2>
            
            <div class="feature-grid">
                <div class="card feature-card">
                    <div class="feature-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14,2 14,8 20,8"/>
                            <line x1="16" y1="13" x2="8" y2="13"/>
                            <line x1="16" y1="17" x2="8" y2="17"/>
                        </svg>
                    </div>
                    <h3>Vault Analysis</h3>
                    <p>Reads and understands your entire vault structure to provide context-aware operations and intelligent suggestions.</p>
                    <div class="tech-stack">
                        <span class="tech-tag">Content Analysis</span>
                        <span class="tech-tag">Structure Mapping</span>
                        <span class="tech-tag">Context Awareness</span>
                    </div>
                </div>

                <div class="card feature-card">
                    <div class="feature-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                            <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                    </div>
                    <h3>Smart Spell Check &amp; Format</h3>
                    <p>Advanced spell checking that respects markdown syntax, plus intelligent formatting for consistent note structure.</p>
                    <div class="tech-stack">
                        <span class="tech-tag">Markdown-Aware</span>
                        <span class="tech-tag">Custom Dictionary</span>
                        <span class="tech-tag">Auto-Format</span>
                    </div>
                </div>

                <div class="card feature-card">
                    <div class="feature-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                            <circle cx="12" cy="12" r="3"/>
                            <path d="m12 1 3 6 6 3-6 3-3 6-3-6-6-3 6-3z"/>
                        </svg>
                    </div>
                    <h3>Semantic Linking</h3>
                    <p>AI-powered analysis to discover and create meaningful connections between your notes based on content similarity.</p>
                    <div class="tech-stack">
                        <span class="tech-tag">AI Analysis</span>
                        <span class="tech-tag">Similarity Detection</span>
                        <span class="tech-tag">Smart Suggestions</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- API Integration Section -->
        <section class="api-info">
            <h4>
                <svg class="warning-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                    <path d="M12 9v4"/>
                    <path d="m12 17 .01 0"/>
                </svg>
                Perplexity API Integration
            </h4>
            <p style="margin-bottom: var(--space-12); color: var(--color-text-secondary);">This plugin requires a Perplexity API key for advanced text analysis and semantic linking features. The API is used for:</p>
            <ul style="color: var(--color-text-secondary); margin: 0; padding-left: var(--space-20);">
                <li>Content understanding and context analysis</li>
                <li>Semantic similarity calculations for smart linking</li>
                <li>Advanced spell checking and grammar suggestions</li>
                <li>Intelligent content reformatting recommendations</li>
            </ul>
        </section>

        <!-- Installation Section -->
        <section class="installation-steps">
            <h3 style="margin-bottom: var(--space-24); text-align: center;">Installation &amp; Setup</h3>
            
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h4>Download the Plugin</h4>
                    <p>Download the plugin files and place them in your Obsidian plugins folder.</p>
                </div>
            </div>

            <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h4>Enable in Obsidian</h4>
                    <p>Go to Settings ‚Üí Community plugins ‚Üí Enable "Perplexity Vault Assistant"</p>
                </div>
            </div>

            <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h4>Configure API Key</h4>
                    <p>Enter your Perplexity API key in the plugin settings to enable AI features.</p>
                </div>
            </div>

            <div class="step">
                <div class="step-number">4</div>
                <div class="step-content">
                    <h4>Start Using</h4>
                    <p>Access plugin functions through the command palette or ribbon icons.</p>
                </div>
            </div>
        </section>

        <!-- Plugin Structure Section -->
        <section>
            <h3 style="margin-bottom: var(--space-24);">Plugin Structure</h3>
            
            <div class="code-block">
                <div class="file-structure">
                    <div class="folder">üìÅ perplexity-vault-assistant/</div>
                    <div style="margin-left: var(--space-16);">
                        <div class="file">üìÑ main.ts - Main plugin class</div>
                        <div class="file">üìÑ manifest.json - Plugin metadata</div>
                        <div class="file">üìÑ settings.ts - Settings interface</div>
                        <div class="file">üìÑ spell-checker.ts - Spell checking utilities</div>
                        <div class="file">üìÑ link-analyzer.ts - Semantic linking logic</div>
                        <div class="file">üìÑ perplexity-api.ts - API integration</div>
                        <div class="file">üìÑ vault-analyzer.ts - Vault content analysis</div>
                        <div class="file">üìÑ ui-components.ts - Modal and UI components</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Download Section -->
        <section class="download-section">
            <h3>Ready to Enhance Your Vault?</h3>
            <p style="color: var(--color-text-secondary); margin-bottom: var(--space-24);">Download the complete plugin source code and start improving your Obsidian workflow with AI-powered features.</p>
            
            <div class="download-buttons">
                <button class="btn btn--primary btn--lg" onclick="downloadPlugin()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: var(--space-8);">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Download Plugin
                </button>
                <button class="btn btn--outline btn--lg" onclick="viewDocumentation()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: var(--space-8);">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                    </svg>
                    View Documentation
                </button>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Perplexity Vault Assistant. Built with TypeScript for Obsidian.</p>
        </div>
    </footer>

    <script>
        /* Plugin file generation and download functionality */
        const pluginFiles = {
            'manifest.json': `{
  "id": "perplexity-vault-assistant",
  "name": "Perplexity Vault Assistant",
  "version": "1.0.0",
  "minAppVersion": "0.15.0",
  "description": "AI-powered vault management with spell checking, formatting, and smart linking using Perplexity API",
  "author": "Plugin Developer",
  "authorUrl": "",
  "fundingUrl": "",
  "isDesktopOnly": false
}`,

            'main.ts': `import { App, Editor, MarkdownView, Modal, Notice, Plugin, PluginSettingTab, Setting, TFile } from 'obsidian';
import { PerplexityVaultSettings, DEFAULT_SETTINGS } from './settings';
import { SpellChecker } from './spell-checker';
import { LinkAnalyzer } from './link-analyzer';
import { PerplexityAPI } from './perplexity-api';
import { VaultAnalyzer } from './vault-analyzer';
import { SpellCheckModal, LinkSuggestionsModal, ProgressModal } from './ui-components';

/**
 * Main plugin class for Perplexity Vault Assistant
 * Provides AI-powered vault management with spell checking, formatting, and smart linking
 */
export default class PerplexityVaultAssistant extends Plugin {
    settings: PerplexityVaultSettings;
    spellChecker: SpellChecker;
    linkAnalyzer: LinkAnalyzer;
    perplexityAPI: PerplexityAPI;
    vaultAnalyzer: VaultAnalyzer;
    cache: Map<string, any> = new Map();

    async onload() {
        // Load settings
        await this.loadSettings();

        // Initialize components
        this.spellChecker = new SpellChecker(this.settings);
        this.linkAnalyzer = new LinkAnalyzer(this.settings);
        this.perplexityAPI = new PerplexityAPI(this.settings.apiKey);
        this.vaultAnalyzer = new VaultAnalyzer(this.app, this.perplexityAPI);

        // Add ribbon icons
        this.addRibbonIcon('search', 'Analyze Vault', () => {
            this.analyzeVault();
        });

        this.addRibbonIcon('spell-check', 'Spell Check Current File', () => {
            this.spellCheckCurrentFile();
        });

        this.addRibbonIcon('link', 'Generate Smart Links', () => {
            this.generateSmartLinks();
        });

        // Add commands
        this.addCommand({
            id: 'analyze-vault',
            name: 'Analyze entire vault',
            callback: () => this.analyzeVault()
        });

        this.addCommand({
            id: 'spell-check-current',
            name: 'Spell check current file',
            editorCallback: (editor: Editor, view: MarkdownView) => {
                this.spellCheckFile(view.file, editor);
            }
        });

        this.addCommand({
            id: 'spell-check-all',
            name: 'Spell check all files',
            callback: () => this.spellCheckAllFiles()
        });

        this.addCommand({
            id: 'format-current',
            name: 'Format current file',
            editorCallback: (editor: Editor, view: MarkdownView) => {
                this.formatFile(view.file, editor);
            }
        });

        this.addCommand({
            id: 'generate-smart-links',
            name: 'Generate smart links for current file',
            editorCallback: (editor: Editor, view: MarkdownView) => {
                this.generateSmartLinksForFile(view.file);
            }
        });

        this.addCommand({
            id: 'generate-all-smart-links',
            name: 'Generate smart links for all files',
            callback: () => this.generateSmartLinks()
        });

        // Add settings tab
        this.addSettingTab(new PerplexityVaultSettingTab(this.app, this));

        console.log('Perplexity Vault Assistant loaded');
    }

    onunload() {
        console.log('Perplexity Vault Assistant unloaded');
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
        // Update components when settings change
        if (this.perplexityAPI) {
            this.perplexityAPI.updateApiKey(this.settings.apiKey);
        }
    }

    /**
     * Analyze the entire vault structure and content
     */
    async analyzeVault() {
        if (!this.settings.apiKey) {
            new Notice('Please set your Perplexity API key in settings first.');
            return;
        }

        const progressModal = new ProgressModal(this.app);
        progressModal.open();
        progressModal.setTitle('Analyzing Vault');
        progressModal.setProgress(0, 'Starting analysis...');

        try {
            const analysis = await this.vaultAnalyzer.analyzeVault((progress, message) => {
                progressModal.setProgress(progress, message);
            });

            // Cache the analysis
            this.cache.set('vault-analysis', {
                data: analysis,
                timestamp: Date.now()
            });

            progressModal.close();
            new Notice('Vault analysis complete!');
            
            // Show results
            this.showVaultAnalysisResults(analysis);
        } catch (error) {
            progressModal.close();
            new Notice('Error analyzing vault: ' + error.message);
            console.error('Vault analysis error:', error);
        }
    }

    /**
     * Spell check the current file
     */
    async spellCheckCurrentFile() {
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (!activeView) {
            new Notice('Please open a markdown file.');
            return;
        }

        await this.spellCheckFile(activeView.file, activeView.editor);
    }

    /**
     * Spell check a specific file
     */
    async spellCheckFile(file: TFile, editor?: Editor) {
        if (!file) return;

        try {
            const content = await this.app.vault.read(file);
            const issues = await this.spellChecker.checkText(content);

            if (issues.length === 0) {
                new Notice('No spelling issues found!');
                return;
            }

            // Show spell check modal
            const modal = new SpellCheckModal(this.app, issues, async (corrections) => {
                if (corrections.length > 0) {
                    let newContent = content;
                    // Apply corrections in reverse order to maintain positions
                    corrections.reverse().forEach(correction => {
                        newContent = newContent.substring(0, correction.start) + 
                                   correction.replacement + 
                                   newContent.substring(correction.end);
                    });

                    await this.app.vault.modify(file, newContent);
                    new Notice(\`Applied \${corrections.length} correction(s).\`);
                }
            });
            modal.open();

        } catch (error) {
            new Notice('Error spell checking file: ' + error.message);
            console.error('Spell check error:', error);
        }
    }

    /**
     * Spell check all files in the vault
     */
    async spellCheckAllFiles() {
        const files = this.app.vault.getMarkdownFiles();
        const progressModal = new ProgressModal(this.app);
        progressModal.open();
        progressModal.setTitle('Spell Checking Files');
        
        let totalIssues = 0;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            progressModal.setProgress((i / files.length) * 100, \`Checking \${file.name}...\`);
            
            try {
                const content = await this.app.vault.read(file);
                const issues = await this.spellChecker.checkText(content);
                totalIssues += issues.length;
                
                // Process in batches to avoid overwhelming
                if (i > 0 && i % this.settings.batchSize === 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            } catch (error) {
                console.error(\`Error checking file \${file.name}:\`, error);
            }
        }
        
        progressModal.close();
        new Notice(\`Spell check complete! Found \${totalIssues} total issues across \${files.length} files.\`);
    }

    /**
     * Format a specific file
     */
    async formatFile(file: TFile, editor?: Editor) {
        if (!file) return;

        try {
            const content = await this.app.vault.read(file);
            const formattedContent = await this.spellChecker.formatMarkdown(content);

            if (content !== formattedContent) {
                await this.app.vault.modify(file, formattedContent);
                new Notice('File formatted successfully.');
            } else {
                new Notice('File is already properly formatted.');
            }
        } catch (error) {
            new Notice('Error formatting file: ' + error.message);
            console.error('Format error:', error);
        }
    }

    /**
     * Generate smart links for all files
     */
    async generateSmartLinks() {
        if (!this.settings.apiKey) {
            new Notice('Please set your Perplexity API key in settings first.');
            return;
        }

        const files = this.app.vault.getMarkdownFiles();
        const progressModal = new ProgressModal(this.app);
        progressModal.open();
        progressModal.setTitle('Generating Smart Links');
        
        let totalSuggestions = 0;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            progressModal.setProgress((i / files.length) * 100, \`Analyzing \${file.name}...\`);
            
            try {
                const suggestions = await this.generateSmartLinksForFile(file, false);
                totalSuggestions += suggestions.length;
                
                // Process in batches
                if (i > 0 && i % this.settings.batchSize === 0) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } catch (error) {
                console.error(\`Error generating links for \${file.name}:\`, error);
            }
        }
        
        progressModal.close();
        new Notice(\`Smart link generation complete! Generated \${totalSuggestions} suggestions.\`);
    }

    /**
     * Generate smart links for a specific file
     */
    async generateSmartLinksForFile(file: TFile, showModal: boolean = true): Promise<any[]> {
        if (!file) return [];

        try {
            const content = await this.app.vault.read(file);
            const allFiles = this.app.vault.getMarkdownFiles();
            
            // Get vault analysis if available
            const vaultAnalysis = this.getCachedData('vault-analysis');
            
            const suggestions = await this.linkAnalyzer.findLinkSuggestions(
                file,
                content,
                allFiles,
                this.app,
                vaultAnalysis
            );

            if (showModal && suggestions.length > 0) {
                const modal = new LinkSuggestionsModal(this.app, suggestions, async (acceptedSuggestions) => {
                    if (acceptedSuggestions.length > 0) {
                        let newContent = content;
                        // Apply suggestions in reverse order
                        acceptedSuggestions.reverse().forEach(suggestion => {
                            const linkText = \`[[\${suggestion.targetFile}]]\`;
                            newContent = newContent.substring(0, suggestion.position) + 
                                       linkText + 
                                       newContent.substring(suggestion.position);
                        });

                        await this.app.vault.modify(file, newContent);
                        new Notice(\`Added \${acceptedSuggestions.length} smart link(s).\`);
                    }
                });
                modal.open();
            } else if (showModal) {
                new Notice('No smart link suggestions found.');
            }

            return suggestions;
        } catch (error) {
            if (showModal) {
                new Notice('Error generating smart links: ' + error.message);
            }
            console.error('Smart links error:', error);
            return [];
        }
    }

    /**
     * Show vault analysis results
     */
    private showVaultAnalysisResults(analysis: any) {
        // This could be expanded to show a detailed modal
        const summary = \`Vault Analysis Complete:
- Total files: \${analysis.totalFiles}
- Total words: \${analysis.totalWords}
- Common topics: \${analysis.topics?.slice(0, 5).join(', ') || 'None identified'}
- Analysis timestamp: \${new Date().toLocaleString()}\`;
        
        new Notice(summary);
    }

    /**
     * Get cached data with expiration check
     */
    private getCachedData(key: string): any {
        const cached = this.cache.get(key);
        if (!cached) return null;
        
        const isExpired = Date.now() - cached.timestamp > this.settings.cacheDuration;
        if (isExpired) {
            this.cache.delete(key);
            return null;
        }
        
        return cached.data;
    }
}

/**
 * Settings tab for the plugin
 */
class PerplexityVaultSettingTab extends PluginSettingTab {
    plugin: PerplexityVaultAssistant;

    constructor(app: App, plugin: PerplexityVaultAssistant) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();
        
        containerEl.createEl('h2', { text: 'Perplexity Vault Assistant Settings' });

        // API Key setting
        new Setting(containerEl)
            .setName('Perplexity API Key')
            .setDesc('Enter your Perplexity API key for AI-powered features')
            .addText(text => text
                .setPlaceholder('pplx-...')
                .setValue(this.plugin.settings.apiKey)
                .onChange(async (value) => {
                    this.plugin.settings.apiKey = value;
                    await this.plugin.saveSettings();
                }));

        // Spell check language
        new Setting(containerEl)
            .setName('Spell Check Language')
            .setDesc('Language for spell checking')
            .addDropdown(dropdown => dropdown
                .addOption('en-US', 'English (US)')
                .addOption('en-GB', 'English (UK)')
                .addOption('es-ES', 'Spanish')
                .addOption('fr-FR', 'French')
                .addOption('de-DE', 'German')
                .setValue(this.plugin.settings.spellCheckLanguage)
                .onChange(async (value) => {
                    this.plugin.settings.spellCheckLanguage = value;
                    await this.plugin.saveSettings();
                }));

        // Auto format toggle
        new Setting(containerEl)
            .setName('Auto Format')
            .setDesc('Automatically format markdown files during spell check')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoFormat)
                .onChange(async (value) => {
                    this.plugin.settings.autoFormat = value;
                    await this.plugin.saveSettings();
                }));

        // Smart linking toggle
        new Setting(containerEl)
            .setName('Smart Linking')
            .setDesc('Enable AI-powered smart link suggestions')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.smartLinking)
                .onChange(async (value) => {
                    this.plugin.settings.smartLinking = value;
                    await this.plugin.saveSettings();
                }));

        // Cache duration
        new Setting(containerEl)
            .setName('Cache Duration (minutes)')
            .setDesc('How long to cache analysis results')
            .addSlider(slider => slider
                .setLimits(5, 120, 5)
                .setValue(this.plugin.settings.cacheDuration / 60000)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.cacheDuration = value * 60000;
                    await this.plugin.saveSettings();
                }));

        // Batch size
        new Setting(containerEl)
            .setName('Batch Size')
            .setDesc('Number of files to process in each batch')
            .addSlider(slider => slider
                .setLimits(1, 50, 1)
                .setValue(this.plugin.settings.batchSize)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.batchSize = value;
                    await this.plugin.saveSettings();
                }));
    }
}`,

            'settings.ts': `/**
 * Settings interface for Perplexity Vault Assistant
 */
export interface PerplexityVaultSettings {
    apiKey: string;
    spellCheckLanguage: string;
    autoFormat: boolean;
    smartLinking: boolean;
    cacheDuration: number; // in milliseconds
    batchSize: number;
    customDictionary: string[];
    excludePatterns: string[];
    minSimilarity: number;
    maxSuggestions: number;
}

/**
 * Default settings for the plugin
 */
export const DEFAULT_SETTINGS: PerplexityVaultSettings = {
    apiKey: '',
    spellCheckLanguage: 'en-US',
    autoFormat: true,
    smartLinking: true,
    cacheDuration: 3600000, // 1 hour
    batchSize: 10,
    customDictionary: [],
    excludePatterns: ['^\\d+$', '^[A-Z]+$'],
    minSimilarity: 0.3,
    maxSuggestions: 5
};`,

            'spell-checker.ts': `import { PerplexityVaultSettings } from './settings';

/**
 * Spell checking utility with markdown awareness
 */
export class SpellChecker {
    private settings: PerplexityVaultSettings;
    private commonWords: Set<string>;
    private customDictionary: Set<string>;

    constructor(settings: PerplexityVaultSettings) {
        this.settings = settings;
        this.initializeDictionaries();
    }

    /**
     * Initialize word dictionaries
     */
    private initializeDictionaries() {
        // Common English words (simplified set)
        this.commonWords = new Set([
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',
            'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
            'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can',
            'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they',
            'me', 'him', 'her', 'us', 'them', 'my', 'your', 'his', 'her', 'its', 'our', 'their',
            'what', 'when', 'where', 'why', 'how', 'which', 'who', 'whom', 'whose',
            'all', 'any', 'some', 'no', 'not', 'only', 'just', 'first', 'last', 'one', 'two',
            'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between'
        ]);

        // Custom dictionary from settings
        this.customDictionary = new Set(this.settings.customDictionary.map(word => word.toLowerCase()));
    }

    /**
     * Check text for spelling issues
     */
    async checkText(text: string): Promise<SpellIssue[]> {
        const issues: SpellIssue[] = [];
        
        // Remove markdown syntax before checking
        const cleanText = this.removeMarkdownSyntax(text);
        
        // Extract words with their positions in the original text
        const words = this.extractWordsWithPositions(text, cleanText);
        
        for (const wordInfo of words) {
            const word = wordInfo.word.toLowerCase();
            
            // Skip if word is in dictionaries
            if (this.isValidWord(word)) {
                continue;
            }
            
            // Skip if matches exclude patterns
            if (this.matchesExcludePattern(word)) {
                continue;
            }
            
            issues.push({
                word: wordInfo.word,
                position: wordInfo.position,
                start: wordInfo.start,
                end: wordInfo.end,
                suggestions: this.getSuggestions(word),
                type: 'spelling'
            });
        }
        
        return issues;
    }

    /**
     * Format markdown text
     */
    async formatMarkdown(text: string): Promise<string> {
        let formatted = text;
        
        // Fix heading spacing
        formatted = formatted.replace(/^(#{1,6})([^\s#])/gm, '$1 $2');
        
        // Fix list spacing
        formatted = formatted.replace(/^(\s*[-\*\+])([^\s])/gm, '$1 $2');
        
        // Fix multiple blank lines
        formatted = formatted.replace(/\n{3,}/g, '\n\n');
        
        // Fix trailing whitespace
        formatted = formatted.replace(/[ \t]+$/gm, '');
        
        // Ensure file ends with single newline
        formatted = formatted.replace(/\n*$/, '\n');
        
        return formatted;
    }

    /**
     * Remove markdown syntax for spell checking
     */
    private removeMarkdownSyntax(text: string): string {
        let clean = text;
        
        // Remove code blocks
        clean = clean.replace(/```[\s\S]*?```/g, '');
        clean = clean.replace(/\`[^\`]+\`/g, '');
        
        // Remove links
        clean = clean.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
        clean = clean.replace(/\[\[([^\]]+)\]\]/g, '$1');
        
        // Remove images
        clean = clean.replace(/!\[([^\]]*)\]\([^\)]+\)/g, '$1');
        
        // Remove HTML tags
        clean = clean.replace(/<[^>]+>/g, '');
        
        // Remove markdown formatting
        clean = clean.replace(/[\*_~\`#]/g, '');
        
        return clean;
    }

    /**
     * Extract words with their positions
     */
    private extractWordsWithPositions(originalText: string, cleanText: string): WordInfo[] {
        const words: WordInfo[] = [];
        const wordRegex = /\b[a-zA-Z]+\b/g;
        let match;
        
        while ((match = wordRegex.exec(cleanText)) !== null) {
            // Find the corresponding position in original text
            const word = match[0];
            const cleanPosition = match.index;
            
            // This is a simplified approach - in a real implementation,
            // you'd need more sophisticated position mapping
            const originalPosition = this.findWordPositionInOriginal(originalText, word, cleanPosition);
            
            if (originalPosition !== -1) {
                words.push({
                    word: word,
                    position: originalPosition,
                    start: originalPosition,
                    end: originalPosition + word.length
                });
            }
        }
        
        return words;
    }

    /**
     * Find word position in original text (simplified)
     */
    private findWordPositionInOriginal(originalText: string, word: string, approximatePosition: number): number {
        // This is a simplified implementation
        // In practice, you'd need more sophisticated position tracking
        const regex = new RegExp('\\b' + word + '\\b', 'gi');
        let match;
        let index = 0;
        
        while ((match = regex.exec(originalText)) !== null) {
            if (Math.abs(match.index - approximatePosition) < 50) {
                return match.index;
            }
            index++;
            if (index > 10) break; // Prevent infinite loops
        }
        
        return -1;
    }

    /**
     * Check if word is valid
     */
    private isValidWord(word: string): boolean {
        return this.commonWords.has(word) || this.customDictionary.has(word);
    }

    /**
     * Check if word matches exclude patterns
     */
    private matchesExcludePattern(word: string): boolean {
        return this.settings.excludePatterns.some(pattern => {
            const regex = new RegExp(pattern, 'i');
            return regex.test(word);
        });
    }

    /**
     * Get spelling suggestions (simplified)
     */
    private getSuggestions(word: string): string[] {
        const suggestions: string[] = [];
        const commonSuggestions = {
            'teh': 'the',
            'adn': 'and',
            'taht': 'that',
            'wiht': 'with',
            'thier': 'their',
            'recieve': 'receive',
            'occured': 'occurred',
            'seperate': 'separate'
        };
        
        if (commonSuggestions[word]) {
            suggestions.push(commonSuggestions[word]);
        }
        
        // Add simple edit distance suggestions
        for (const commonWord of Array.from(this.commonWords)) {
            if (this.editDistance(word, commonWord) <= 2 && commonWord.length >= 3) {
                suggestions.push(commonWord);
            }
        }
        
        return suggestions.slice(0, 5); // Limit suggestions
    }

    /**
     * Calculate edit distance between two words
     */
    private editDistance(word1: string, word2: string): number {
        const matrix = [];
        
        for (let i = 0; i <= word2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= word1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= word2.length; i++) {
            for (let j = 1; j <= word1.length; j++) {
                if (word2.charAt(i - 1) === word1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // substitution
                        matrix[i][j - 1] + 1,     // insertion
                        matrix[i - 1][j] + 1      // deletion
                    );
                }
            }
        }
        
        return matrix[word2.length][word1.length];
    }

    /**
     * Add word to custom dictionary
     */
    addToCustomDictionary(word: string) {
        this.customDictionary.add(word.toLowerCase());
        this.settings.customDictionary.push(word.toLowerCase());
    }
}

/**
 * Interface for spell checking issues
 */
export interface SpellIssue {
    word: string;
    position: number;
    start: number;
    end: number;
    suggestions: string[];
    type: 'spelling' | 'grammar';
}

/**
 * Interface for word information
 */
interface WordInfo {
    word: string;
    position: number;
    start: number;
    end: number;
}`,

            'link-analyzer.ts': `import { TFile, App } from 'obsidian';
import { PerplexityVaultSettings } from './settings';

/**
 * Semantic link analyzer for creating intelligent connections between notes
 */
export class LinkAnalyzer {
    private settings: PerplexityVaultSettings;

    constructor(settings: PerplexityVaultSettings) {
        this.settings = settings;
    }

    /**
     * Find link suggestions for a file
     */
    async findLinkSuggestions(
        sourceFile: TFile,
        sourceContent: string,
        allFiles: TFile[],
        app: App,
        vaultAnalysis?: any
    ): Promise<LinkSuggestion[]> {
        const suggestions: LinkSuggestion[] = [];
        
        // Extract keywords from source content
        const sourceKeywords = this.extractKeywords(sourceContent);
        
        // Analyze each potential target file
        for (const targetFile of allFiles) {
            if (targetFile.path === sourceFile.path) continue;
            
            try {
                const targetContent = await app.vault.read(targetFile);
                const targetKeywords = this.extractKeywords(targetContent);
                
                // Calculate semantic similarity
                const similarity = this.calculateSimilarity(sourceKeywords, targetKeywords);
                
                if (similarity >= this.settings.minSimilarity) {
                    // Find good positions to insert links
                    const positions = this.findLinkPositions(sourceContent, targetFile.basename, targetKeywords);
                    
                    for (const position of positions) {
                        suggestions.push({
                            sourceFile: sourceFile.path,
                            targetFile: targetFile.basename,
                            similarity: similarity,
                            position: position.index,
                            context: position.context,
                            reason: \`Similar content about: \${position.matchedKeywords.join(', ')}\`
                        });
                    }
                }
            } catch (error) {
                console.error(\`Error analyzing file \${targetFile.path}:\`, error);
            }
        }
        
        // Sort by similarity and limit results
        suggestions.sort((a, b) => b.similarity - a.similarity);
        return suggestions.slice(0, this.settings.maxSuggestions);
    }

    /**
     * Extract keywords from text content
     */
    private extractKeywords(content: string): Map<string, number> {
        const keywords = new Map<string, number>();
        
        // Clean content
        let cleanContent = this.cleanTextForAnalysis(content);
        
        // Extract words
        const words = cleanContent.toLowerCase().match(/\b[a-z]{3,}\b/g) || [];
        
        // Count word frequencies
        for (const word of words) {
            if (!this.isStopWord(word)) {
                keywords.set(word, (keywords.get(word) || 0) + 1);
            }
        }
        
        // Extract noun phrases and compound terms
        this.extractPhrases(cleanContent).forEach(phrase => {
            keywords.set(phrase, (keywords.get(phrase) || 0) + 2); // Weight phrases higher
        });
        
        return keywords;
    }

    /**
     * Clean text for keyword analysis
     */
    private cleanTextForAnalysis(text: string): string {
        let clean = text;
        
        // Remove code blocks
        clean = clean.replace(/```[\s\S]*?```/g, ' ');
        clean = clean.replace(/`[^`]+`/g, ' ');
        
        // Remove links but keep the text
        clean = clean.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
        clean = clean.replace(/\[\[([^\]]+)\]\]/g, '$1');
        
        // Remove images
        clean = clean.replace(/!\[([^\]]*)\]\([^\)]+\)/g, '');
        
        // Remove HTML
        clean = clean.replace(/<[^>]+>/g, ' ');
        
        // Remove markdown formatting
        clean = clean.replace(/[\*_~`#]/g, '');
        
        // Remove special characters but keep spaces
        clean = clean.replace(/[^a-zA-Z0-9\s]/g, ' ');
        
        // Normalize whitespace
        clean = clean.replace(/\s+/g, ' ').trim();
        
        return clean;
    }

    /**
     * Extract meaningful phrases from text
     */
    private extractPhrases(text: string): string[] {
        const phrases: string[] = [];
        
        // Simple phrase extraction using patterns
        const words = text.split(/\s+/);
        
        for (let i = 0; i < words.length - 1; i++) {
            const word1 = words[i].toLowerCase();
            const word2 = words[i + 1].toLowerCase();
            
            if (word1.length >= 3 && word2.length >= 3 && 
                !this.isStopWord(word1) && !this.isStopWord(word2)) {
                phrases.push(\`\${word1} \${word2}\`);
            }
        }
        
        // Extract capitalized terms (likely proper nouns)
        const properNouns = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
        phrases.push(...properNouns.map(noun => noun.toLowerCase()));
        
        return phrases;
    }

    /**
     * Calculate semantic similarity between keyword sets
     */
    private calculateSimilarity(keywords1: Map<string, number>, keywords2: Map<string, number>): number {
        if (keywords1.size === 0 || keywords2.size === 0) return 0;
        
        const keys1 = new Set(keywords1.keys());
        const keys2 = new Set(keywords2.keys());
        
        // Calculate Jaccard similarity with frequency weighting
        let intersection = 0;
        let union = 0;
        
        const allKeys = new Set([...keys1, ...keys2]);
        
        for (const key of allKeys) {
            const freq1 = keywords1.get(key) || 0;
            const freq2 = keywords2.get(key) || 0;
            
            if (freq1 > 0 && freq2 > 0) {
                intersection += Math.min(freq1, freq2);
            }
            union += Math.max(freq1, freq2);
        }
        
        return union > 0 ? intersection / union : 0;
    }

    /**
     * Find good positions to insert links
     */
    private findLinkPositions(content: string, targetFileName: string, targetKeywords: Map<string, number>): LinkPosition[] {
        const positions: LinkPosition[] = [];
        
        // Look for mentions of target keywords in source content
        const sortedKeywords = Array.from(targetKeywords.entries())
            .sort((a, b) => b[1] - a[1]) // Sort by frequency
            .slice(0, 10); // Take top keywords
        
        for (const [keyword, frequency] of sortedKeywords) {
            if (keyword.length < 3) continue;
            
            const regex = new RegExp('\\b' + this.escapeRegex(keyword) + '\\b', 'gi');
            let match;
            
            while ((match = regex.exec(content)) !== null) {
                // Check if this position is not already a link
                if (!this.isAlreadyLinked(content, match.index)) {
                    const context = this.getContext(content, match.index, 50);
                    
                    positions.push({
                        index: match.index,
                        context: context,
                        matchedKeywords: [keyword]
                    });
                }
                
                // Prevent infinite loops
                if (positions.length > 20) break;
            }
        }
        
        return positions;
    }

    /**
     * Check if position is already part of a link
     */
    private isAlreadyLinked(content: string, position: number): boolean {
        // Check for [[]] links
        const beforePos = Math.max(0, position - 50);
        const afterPos = Math.min(content.length, position + 50);
        const context = content.substring(beforePos, afterPos);
        
        // Simple check for existing links
        return context.includes('[[') || context.includes('](') || context.includes('<');
    }

    /**
     * Get context around a position
     */
    private getContext(content: string, position: number, radius: number): string {
        const start = Math.max(0, position - radius);
        const end = Math.min(content.length, position + radius);
        return content.substring(start, end).trim();
    }

    /**
     * Check if word is a stop word
     */
    private isStopWord(word: string): boolean {
        const stopWords = new Set([
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',
            'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
            'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can',
            'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they',
            'me', 'him', 'her', 'us', 'them', 'my', 'your', 'his', 'her', 'its', 'our', 'their',
            'what', 'when', 'where', 'why', 'how', 'which', 'who', 'whom', 'whose',
            'all', 'any', 'some', 'no', 'not', 'only', 'just', 'first', 'last', 'one', 'two'
        ]);
        return stopWords.has(word.toLowerCase());
    }

    /**
     * Escape special regex characters
     */
    private escapeRegex(string: string): string {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
}

/**
 * Interface for link suggestions
 */
export interface LinkSuggestion {
    sourceFile: string;
    targetFile: string;
    similarity: number;
    position: number;
    context: string;
    reason: string;
}

/**
 * Interface for link positions
 */
interface LinkPosition {
    index: number;
    context: string;
    matchedKeywords: string[];
}`,

            'perplexity-api.ts': `/**
 * Perplexity API integration for advanced text analysis
 */
export class PerplexityAPI {
    private apiKey: string;
    private baseUrl = 'https://api.perplexity.ai';
    private rateLimitDelay = 1000; // 1 second between requests
    private lastRequestTime = 0;

    constructor(apiKey: string) {
        this.apiKey = apiKey;
    }

    /**
     * Update API key
     */
    updateApiKey(apiKey: string) {
        this.apiKey = apiKey;
    }

    /**
     * Analyze text content for themes and topics
     */
    async analyzeContent(text: string): Promise<ContentAnalysis> {
        if (!this.apiKey) {
            throw new Error('API key is required');
        }

        await this.respectRateLimit();

        const prompt = \`Analyze the following text and extract:
1. Main topics (up to 10)
2. Key themes
3. Important entities (people, places, concepts)
4. Summary in 2-3 sentences

Text:
\${text}

Respond in JSON format with: {"topics": [], "themes": [], "entities": [], "summary": ""}\`;

        try {
            const response = await this.makeRequest('/chat/completions', {
                model: 'llama-3.1-sonar-small-128k-online',
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.3,
                max_tokens: 1000
            });

            const content = response.choices[0].message.content;
            return this.parseAnalysisResponse(content);
        } catch (error) {
            console.error('Error analyzing content:', error);
            throw new Error(\`Content analysis failed: \${error.message}\`);
        }
    }

    /**
     * Get semantic similarity between two texts
     */
    async getSemanticSimilarity(text1: string, text2: string): Promise<number> {
        if (!this.apiKey) {
            throw new Error('API key is required');
        }

        await this.respectRateLimit();

        const prompt = \`Compare these two texts and provide a semantic similarity score from 0.0 to 1.0, where 0.0 means completely unrelated and 1.0 means identical in meaning.

Text 1: \${text1.substring(0, 500)}

Text 2: \${text2.substring(0, 500)}

Respond with only the numeric score (e.g., 0.75):\`;

        try {
            const response = await this.makeRequest('/chat/completions', {
                model: 'llama-3.1-sonar-small-128k-online',
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.1,
                max_tokens: 10
            });

            const content = response.choices[0].message.content;
            const score = parseFloat(content.trim());
            return isNaN(score) ? 0 : Math.max(0, Math.min(1, score));
        } catch (error) {
            console.error('Error calculating similarity:', error);
            return 0; // Return 0 similarity on error
        }
    }

    /**
     * Get spelling and grammar suggestions
     */
    async getSpellingSuggestions(text: string): Promise<SpellingSuggestion[]> {
        if (!this.apiKey) {
            throw new Error('API key is required');
        }

        await this.respectRateLimit();

        const prompt = \`Review the following text for spelling and grammar errors. Provide suggestions in JSON format.

Text: \${text}

Respond with: {"suggestions": [{"original": "word", "suggestion": "correction", "type": "spelling|grammar", "position": number}]}\`;

        try {
            const response = await this.makeRequest('/chat/completions', {
                model: 'llama-3.1-sonar-small-128k-online',
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.2,
                max_tokens: 1000
            });

            const content = response.choices[0].message.content;
            return this.parseSpellingSuggestions(content);
        } catch (error) {
            console.error('Error getting spelling suggestions:', error);
            return [];
        }
    }

    /**
     * Make HTTP request to Perplexity API
     */
    private async makeRequest(endpoint: string, data: any): Promise<any> {
        const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': \`Bearer \${this.apiKey}\`
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(\`API request failed: \${response.status} \${errorText}\`);
        }

        return await response.json();
    }

    /**
     * Respect rate limiting
     */
    private async respectRateLimit() {
        const now = Date.now();
        const timeSinceLastRequest = now - this.lastRequestTime;
        
        if (timeSinceLastRequest < this.rateLimitDelay) {
            await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest));
        }
        
        this.lastRequestTime = Date.now();
    }

    /**
     * Parse content analysis response
     */
    private parseAnalysisResponse(content: string): ContentAnalysis {
        try {
            const parsed = JSON.parse(content);
            return {
                topics: parsed.topics || [],
                themes: parsed.themes || [],
                entities: parsed.entities || [],
                summary: parsed.summary || ''
            };
        } catch (error) {
            console.error('Error parsing analysis response:', error);
            return {
                topics: [],
                themes: [],
                entities: [],
                summary: 'Failed to analyze content'
            };
        }
    }

    /**
     * Parse spelling suggestions response
     */
    private parseSpellingSuggestions(content: string): SpellingSuggestion[] {
        try {
            const parsed = JSON.parse(content);
            return parsed.suggestions || [];
        } catch (error) {
            console.error('Error parsing spelling suggestions:', error);
            return [];
        }
    }
}

/**
 * Interface for content analysis results
 */
export interface ContentAnalysis {
    topics: string[];
    themes: string[];
    entities: string[];
    summary: string;
}

/**
 * Interface for spelling suggestions
 */
export interface SpellingSuggestion {
    original: string;
    suggestion: string;
    type: 'spelling' | 'grammar';
    position: number;
}`,

            'vault-analyzer.ts': `import { App, TFile } from 'obsidian';
import { PerplexityAPI, ContentAnalysis } from './perplexity-api';

/**
 * Analyzes the entire vault structure and content
 */
export class VaultAnalyzer {
    private app: App;
    private perplexityAPI: PerplexityAPI;

    constructor(app: App, perplexityAPI: PerplexityAPI) {
        this.app = app;
        this.perplexityAPI = perplexityAPI;
    }

    /**
     * Analyze the entire vault
     */
    async analyzeVault(progressCallback?: (progress: number, message: string) => void): Promise<VaultAnalysis> {
        const files = this.app.vault.getMarkdownFiles();
        const analysis: VaultAnalysis = {
            totalFiles: files.length,
            totalWords: 0,
            topics: [],
            themes: [],
            entities: [],
            fileAnalyses: new Map(),
            connections: [],
            summary: ''
        };

        let processedFiles = 0;
        
        // Analyze each file
        for (const file of files) {
            try {
                progressCallback?.(processedFiles / files.length * 50, \`Analyzing \${file.name}...\`);
                
                const content = await this.app.vault.read(file);
                const wordCount = this.countWords(content);
                analysis.totalWords += wordCount;

                // Get AI analysis for significant files (over 100 words)
                if (wordCount > 100) {
                    try {
                        const contentAnalysis = await this.perplexityAPI.analyzeContent(content);
                        analysis.fileAnalyses.set(file.path, {
                            file: file.path,
                            wordCount: wordCount,
                            analysis: contentAnalysis
                        });
                        
                        // Aggregate topics and themes
                        this.aggregateTopics(analysis, contentAnalysis);
                    } catch (error) {
                        console.error(\`Error analyzing file \${file.path}:\`, error);
                        // Continue with basic analysis
                        analysis.fileAnalyses.set(file.path, {
                            file: file.path,
                            wordCount: wordCount,
                            analysis: {
                                topics: this.extractBasicTopics(content),
                                themes: [],
                                entities: [],
                                summary: this.createBasicSummary(content)
                            }
                        });
                    }
                } else {
                    // Basic analysis for short files
                    analysis.fileAnalyses.set(file.path, {
                        file: file.path,
                        wordCount: wordCount,
                        analysis: {
                            topics: this.extractBasicTopics(content),
                            themes: [],
                            entities: [],
                            summary: this.createBasicSummary(content)
                        }
                    });
                }

                processedFiles++;
                
                // Small delay to prevent overwhelming the API
                if (processedFiles % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            } catch (error) {
                console.error(\`Error processing file \${file.path}:\`, error);
                processedFiles++;
            }
        }

        // Analyze connections between files
        progressCallback?.(75, 'Analyzing connections...');
        analysis.connections = await this.analyzeConnections(analysis.fileAnalyses);

        // Create overall summary
        progressCallback?.(90, 'Generating summary...');
        analysis.summary = await this.createVaultSummary(analysis);
        
        progressCallback?.(100, 'Analysis complete!');
        return analysis;
    }

    /**
     * Count words in content
     */
    private countWords(content: string): number {
        // Remove markdown syntax and count words
        const cleanContent = content
            .replace(/```[\s\S]*?```/g, '') // Remove code blocks
            .replace(/\`[^\`]+\`/g, '') // Remove inline code
            .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Keep link text
            .replace(/[\*_~#]/g, '') // Remove formatting
            .replace(/[^a-zA-Z\s]/g, ' ') // Keep only letters and spaces
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
        
        return cleanContent ? cleanContent.split(' ').length : 0;
    }

    /**
     * Extract basic topics from content without API
     */
    private extractBasicTopics(content: string): string[] {
        const topics: string[] = [];
        
        // Extract headings as topics
        const headings = content.match(/^#+\s+(.+)$/gm);
        if (headings) {
            headings.forEach(heading => {
                const topic = heading.replace(/^#+\s+/, '').trim();
                if (topic.length > 2 && topic.length < 50) {
                    topics.push(topic);
                }
            });
        }
        
        // Extract capitalized phrases (likely proper nouns/topics)
        const properNouns = content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
        const uniqueNouns = [...new Set(properNouns)]
            .filter(noun => noun.length > 2 && noun.length < 30)
            .slice(0, 10);
        
        topics.push(...uniqueNouns);
        
        return [...new Set(topics)].slice(0, 10);
    }

    /**
     * Create basic summary without API
     */
    private createBasicSummary(content: string): string {
        // Take first paragraph or first 200 characters
        const firstParagraph = content.split('\n\n')[0];
        const cleanParagraph = firstParagraph
            .replace(/^#+\s+/, '') // Remove heading markers
            .replace(/[\*_~#\[\]]/g, '') // Remove formatting
            .trim();
        
        if (cleanParagraph.length > 200) {
            return cleanParagraph.substring(0, 200) + '...';
        }
        
        return cleanParagraph || 'No summary available';
    }

    /**
     * Aggregate topics and themes from file analyses
     */
    private aggregateTopics(vaultAnalysis: VaultAnalysis, fileAnalysis: ContentAnalysis) {
        // Count occurrences of topics
        const topicCounts = new Map<string, number>();
        const themeCounts = new Map<string, number>();
        
        // Add current topics
        vaultAnalysis.topics.forEach(topic => {
            topicCounts.set(topic, (topicCounts.get(topic) || 0));
        });
        
        fileAnalysis.topics.forEach(topic => {
            topicCounts.set(topic, (topicCounts.get(topic) || 0) + 1);
        });
        
        // Add current themes
        vaultAnalysis.themes.forEach(theme => {
            themeCounts.set(theme, (themeCounts.get(theme) || 0));
        });
        
        fileAnalysis.themes.forEach(theme => {
            themeCounts.set(theme, (themeCounts.get(theme) || 0) + 1);
        });
        
        // Update vault-level topics and themes
        vaultAnalysis.topics = Array.from(topicCounts.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20)
            .map(entry => entry[0]);
        
        vaultAnalysis.themes = Array.from(themeCounts.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 15)
            .map(entry => entry[0]);
        
        // Aggregate entities
        fileAnalysis.entities.forEach(entity => {
            if (!vaultAnalysis.entities.includes(entity)) {
                vaultAnalysis.entities.push(entity);
            }
        });
        
        vaultAnalysis.entities = vaultAnalysis.entities.slice(0, 50);
    }

    /**
     * Analyze connections between files
     */
    private async analyzeConnections(fileAnalyses: Map<string, FileAnalysis>): Promise<Connection[]> {
        const connections: Connection[] = [];
        const files = Array.from(fileAnalyses.keys());
        
        // Compare each pair of files
        for (let i = 0; i < files.length; i++) {
            for (let j = i + 1; j < Math.min(files.length, i + 20); j++) { // Limit comparisons
                const file1 = files[i];
                const file2 = files[j];
                const analysis1 = fileAnalyses.get(file1);
                const analysis2 = fileAnalyses.get(file2);
                
                if (analysis1 && analysis2) {
                    const similarity = this.calculateTopicSimilarity(
                        analysis1.analysis.topics,
                        analysis2.analysis.topics
                    );
                    
                    if (similarity > 0.3) {
                        connections.push({
                            file1: file1,
                            file2: file2,
                            similarity: similarity,
                            sharedTopics: this.findSharedTopics(
                                analysis1.analysis.topics,
                                analysis2.analysis.topics
                            )
                        });
                    }
                }
            }
        }
        
        return connections.sort((a, b) => b.similarity - a.similarity).slice(0, 50);
    }

    /**
     * Calculate similarity between topic arrays
     */
    private calculateTopicSimilarity(topics1: string[], topics2: string[]): number {
        if (topics1.length === 0 || topics2.length === 0) return 0;
        
        const set1 = new Set(topics1.map(t => t.toLowerCase()));
        const set2 = new Set(topics2.map(t => t.toLowerCase()));
        
        const intersection = new Set([...set1].filter(x => set2.has(x)));
        const union = new Set([...set1, ...set2]);
        
        return intersection.size / union.size;
    }

    /**
     * Find shared topics between two arrays
     */
    private findSharedTopics(topics1: string[], topics2: string[]): string[] {
        const set1 = new Set(topics1.map(t => t.toLowerCase()));
        return topics2.filter(topic => set1.has(topic.toLowerCase()));
    }

    /**
     * Create overall vault summary
     */
    private async createVaultSummary(analysis: VaultAnalysis): Promise<string> {
        const topTopics = analysis.topics.slice(0, 5).join(', ');
        const topThemes = analysis.themes.slice(0, 3).join(', ');
        
        return \`This vault contains \${analysis.totalFiles} files with \${analysis.totalWords} total words. ` +
               \`The main topics include: \${topTopics}. ` +
               \`Key themes are: \${topThemes}. ` +
               \`There are \${analysis.connections.length} significant connections between files.\`;
    }
}

/**
 * Interface for vault analysis results
 */
export interface VaultAnalysis {
    totalFiles: number;
    totalWords: number;
    topics: string[];
    themes: string[];
    entities: string[];
    fileAnalyses: Map<string, FileAnalysis>;
    connections: Connection[];
    summary: string;
}

/**
 * Interface for individual file analysis
 */
export interface FileAnalysis {
    file: string;
    wordCount: number;
    analysis: ContentAnalysis;
}

/**
 * Interface for connections between files
 */
export interface Connection {
    file1: string;
    file2: string;
    similarity: number;
    sharedTopics: string[];
}`,

            'ui-components.ts': `import { App, Modal, Setting, Notice } from 'obsidian';
import { SpellIssue } from './spell-checker';
import { LinkSuggestion } from './link-analyzer';

/**
 * Modal for displaying spell check results and corrections
 */
export class SpellCheckModal extends Modal {
    private issues: SpellIssue[];
    private onApply: (corrections: Correction[]) => Promise<void>;
    private corrections: Correction[] = [];

    constructor(
        app: App, 
        issues: SpellIssue[], 
        onApply: (corrections: Correction[]) => Promise<void>
    ) {
        super(app);
        this.issues = issues;
        this.onApply = onApply;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl('h2', { text: 'Spell Check Results' });
        
        if (this.issues.length === 0) {
            contentEl.createEl('p', { text: 'No spelling issues found!' });
            return;
        }

        contentEl.createEl('p', { 
            text: \`Found \${this.issues.length} potential spelling issue(s). Review and select corrections:\` 
        });

        // Create scrollable container for issues
        const issuesContainer = contentEl.createEl('div', {
            cls: 'spell-check-issues'
        });
        issuesContainer.style.maxHeight = '400px';
        issuesContainer.style.overflowY = 'auto';
        issuesContainer.style.border = '1px solid var(--background-modifier-border)';
        issuesContainer.style.borderRadius = '6px';
        issuesContainer.style.padding = '10px';
        issuesContainer.style.marginBottom = '20px';

        this.issues.forEach((issue, index) => {
            this.createIssueElement(issuesContainer, issue, index);
        });

        // Action buttons
        const buttonContainer = contentEl.createEl('div', {
            cls: 'spell-check-buttons'
        });
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.style.justifyContent = 'flex-end';

        const applyButton = buttonContainer.createEl('button', {
            text: 'Apply Selected',
            cls: 'mod-cta'
        });
        applyButton.onclick = () => this.applyCorrections();

        const cancelButton = buttonContainer.createEl('button', {
            text: 'Cancel'
        });
        cancelButton.onclick = () => this.close();
    }

    private createIssueElement(container: HTMLElement, issue: SpellIssue, index: number) {
        const issueEl = container.createEl('div', {
            cls: 'spell-issue'
        });
        issueEl.style.padding = '10px';
        issueEl.style.borderBottom = '1px solid var(--background-modifier-border-focus)';
        issueEl.style.marginBottom = '10px';

        // Issue header
        const headerEl = issueEl.createEl('div', {
            cls: 'spell-issue-header'
        });
        headerEl.style.display = 'flex';
        headerEl.style.alignItems = 'center';
        headerEl.style.marginBottom = '8px';

        const wordEl = headerEl.createEl('span', {
            text: issue.word,
            cls: 'spell-issue-word'
        });
        wordEl.style.fontWeight = 'bold';
        wordEl.style.color = 'var(--text-error)';
        wordEl.style.marginRight = '10px';

        const typeEl = headerEl.createEl('span', {
            text: \`(\${issue.type})\`,
            cls: 'spell-issue-type'
        });
        typeEl.style.fontSize = '0.9em';
        typeEl.style.color = 'var(--text-muted)';

        // Suggestions
        if (issue.suggestions.length > 0) {
            const suggestionsEl = issueEl.createEl('div', {
                cls: 'spell-suggestions'
            });
            suggestionsEl.style.display = 'flex';
            suggestionsEl.style.flexWrap = 'wrap';
            suggestionsEl.style.gap = '5px';
            suggestionsEl.style.marginBottom = '8px';

            issue.suggestions.forEach(suggestion => {
                const suggestionBtn = suggestionsEl.createEl('button', {
                    text: suggestion,
                    cls: 'spell-suggestion'
                });
                suggestionBtn.style.padding = '4px 8px';
                suggestionBtn.style.border = '1px solid var(--interactive-accent)';
                suggestionBtn.style.borderRadius = '4px';
                suggestionBtn.style.backgroundColor = 'transparent';
                suggestionBtn.style.cursor = 'pointer';
                
                suggestionBtn.onclick = () => {
                    this.selectCorrection(index, issue, suggestion);
                    suggestionBtn.style.backgroundColor = 'var(--interactive-accent)';
                    suggestionBtn.style.color = 'var(--text-on-accent)';
                    
                    // Deselect other suggestions
                    suggestionsEl.querySelectorAll('button').forEach(btn => {
                        if (btn !== suggestionBtn) {
                            btn.style.backgroundColor = 'transparent';
                            btn.style.color = 'inherit';
                        }
                    });
                };
            });
        }

        // Ignore button
        const ignoreBtn = issueEl.createEl('button', {
            text: 'Ignore',
            cls: 'spell-ignore'
        });
        ignoreBtn.style.padding = '4px 12px';
        ignoreBtn.style.border = '1px solid var(--text-muted)';
        ignoreBtn.style.borderRadius = '4px';
        ignoreBtn.style.backgroundColor = 'transparent';
        ignoreBtn.onclick = () => {
            issueEl.style.opacity = '0.5';
            this.removeCorrection(index);
        };
    }

    private selectCorrection(index: number, issue: SpellIssue, replacement: string) {
        // Remove existing correction for this issue
        this.corrections = this.corrections.filter(c => c.issueIndex !== index);
        
        // Add new correction
        this.corrections.push({
            issueIndex: index,
            start: issue.start,
            end: issue.end,
            replacement: replacement
        });
    }

    private removeCorrection(index: number) {
        this.corrections = this.corrections.filter(c => c.issueIndex !== index);
    }

    private async applyCorrections() {
        if (this.corrections.length === 0) {
            new Notice('No corrections selected.');
            return;
        }

        try {
            await this.onApply(this.corrections);
            this.close();
        } catch (error) {
            new Notice('Error applying corrections: ' + error.message);
        }
    }

    onClose() {
        this.contentEl.empty();
    }
}

/**
 * Modal for displaying link suggestions
 */
export class LinkSuggestionsModal extends Modal {
    private suggestions: LinkSuggestion[];
    private onApply: (suggestions: LinkSuggestion[]) => Promise<void>;
    private selectedSuggestions: LinkSuggestion[] = [];

    constructor(
        app: App, 
        suggestions: LinkSuggestion[], 
        onApply: (suggestions: LinkSuggestion[]) => Promise<void>
    ) {
        super(app);
        this.suggestions = suggestions;
        this.onApply = onApply;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl('h2', { text: 'Smart Link Suggestions' });
        
        if (this.suggestions.length === 0) {
            contentEl.createEl('p', { text: 'No link suggestions found.' });
            return;
        }

        contentEl.createEl('p', { 
            text: \`Found \${this.suggestions.length} potential link(s). Select which ones to add:\` 
        });

        // Create scrollable container
        const suggestionsContainer = contentEl.createEl('div', {
            cls: 'link-suggestions'
        });
        suggestionsContainer.style.maxHeight = '400px';
        suggestionsContainer.style.overflowY = 'auto';
        suggestionsContainer.style.border = '1px solid var(--background-modifier-border)';
        suggestionsContainer.style.borderRadius = '6px';
        suggestionsContainer.style.padding = '10px';
        suggestionsContainer.style.marginBottom = '20px';

        this.suggestions.forEach((suggestion, index) => {
            this.createSuggestionElement(suggestionsContainer, suggestion, index);
        });

        // Action buttons
        const buttonContainer = contentEl.createEl('div', {
            cls: 'link-suggestion-buttons'
        });
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.style.justifyContent = 'flex-end';

        const selectAllButton = buttonContainer.createEl('button', {
            text: 'Select All'
        });
        selectAllButton.onclick = () => this.selectAll();

        const applyButton = buttonContainer.createEl('button', {
            text: 'Add Selected Links',
            cls: 'mod-cta'
        });
        applyButton.onclick = () => this.applySelected();

        const cancelButton = buttonContainer.createEl('button', {
            text: 'Cancel'
        });
        cancelButton.onclick = () => this.close();
    }

    private createSuggestionElement(container: HTMLElement, suggestion: LinkSuggestion, index: number) {
        const suggestionEl = container.createEl('div', {
            cls: 'link-suggestion'
        });
        suggestionEl.style.padding = '12px';
        suggestionEl.style.borderBottom = '1px solid var(--background-modifier-border-focus)';
        suggestionEl.style.marginBottom = '10px';
        suggestionEl.style.cursor = 'pointer';

        // Checkbox
        const checkboxContainer = suggestionEl.createEl('div', {
            cls: 'link-suggestion-header'
        });
        checkboxContainer.style.display = 'flex';
        checkboxContainer.style.alignItems = 'flex-start';
        checkboxContainer.style.gap = '10px';

        const checkbox = checkboxContainer.createEl('input', {
            type: 'checkbox'
        }) as HTMLInputElement;
        checkbox.style.marginTop = '2px';
        checkbox.onchange = () => {
            if (checkbox.checked) {
                this.selectedSuggestions.push(suggestion);
                suggestionEl.style.backgroundColor = 'var(--background-modifier-hover)';
            } else {
                this.selectedSuggestions = this.selectedSuggestions.filter(s => s !== suggestion);
                suggestionEl.style.backgroundColor = 'transparent';
            }
        };

        const contentContainer = checkboxContainer.createEl('div', {
            cls: 'link-suggestion-content'
        });
        contentContainer.style.flex = '1';

        // Target file
        const targetEl = contentContainer.createEl('div', {
            cls: 'link-target'
        });
        targetEl.style.fontWeight = 'bold';
        targetEl.style.marginBottom = '4px';
        targetEl.createEl('span', { text: 'Link to: ' });
        targetEl.createEl('span', { 
            text: suggestion.targetFile,
            cls: 'link-target-file'
        }).style.color = 'var(--interactive-accent)';

        // Similarity score
        const similarityEl = contentContainer.createEl('div', {
            cls: 'link-similarity'
        });
        similarityEl.style.fontSize = '0.9em';
        similarityEl.style.color = 'var(--text-muted)';
        similarityEl.style.marginBottom = '6px';
        similarityEl.textContent = \`Similarity: \${(suggestion.similarity * 100).toFixed(1)}%\`;

        // Context
        const contextEl = contentContainer.createEl('div', {
            cls: 'link-context'
        });
        contextEl.style.fontSize = '0.85em';
        contextEl.style.color = 'var(--text-muted)';
        contextEl.style.fontStyle = 'italic';
        contextEl.style.marginBottom = '6px';
        contextEl.textContent = \`Context: "...\${suggestion.context}..."\`;

        // Reason
        const reasonEl = contentContainer.createEl('div', {
            cls: 'link-reason'
        });
        reasonEl.style.fontSize = '0.85em';
        reasonEl.style.color = 'var(--text-accent)';
        reasonEl.textContent = suggestion.reason;

        // Click to toggle
        suggestionEl.onclick = (e) => {
            if (e.target !== checkbox) {
                checkbox.click();
            }
        };
    }

    private selectAll() {
        const checkboxes = this.contentEl.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
        checkboxes.forEach(checkbox => {
            if (!checkbox.checked) {
                checkbox.click();
            }
        });
    }

    private async applySelected() {
        if (this.selectedSuggestions.length === 0) {
            new Notice('No suggestions selected.');
            return;
        }

        try {
            await this.onApply(this.selectedSuggestions);
            this.close();
        } catch (error) {
            new Notice('Error adding links: ' + error.message);
        }
    }

    onClose() {
        this.contentEl.empty();
    }
}

/**
 * Modal for showing progress during long operations
 */
export class ProgressModal extends Modal {
    private titleEl: HTMLElement;
    private progressEl: HTMLElement;
    private messageEl: HTMLElement;

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        this.titleEl = contentEl.createEl('h2', { text: 'Processing...' });
        
        const progressContainer = contentEl.createEl('div', {
            cls: 'progress-container'
        });
        progressContainer.style.marginBottom = '20px';
        
        const progressBar = progressContainer.createEl('div', {
            cls: 'progress-bar'
        });
        progressBar.style.width = '100%';
        progressBar.style.height = '8px';
        progressBar.style.backgroundColor = 'var(--background-modifier-border)';
        progressBar.style.borderRadius = '4px';
        progressBar.style.overflow = 'hidden';
        
        this.progressEl = progressBar.createEl('div', {
            cls: 'progress-fill'
        });
        this.progressEl.style.height = '100%';
        this.progressEl.style.backgroundColor = 'var(--interactive-accent)';
        this.progressEl.style.width = '0%';
        this.progressEl.style.transition = 'width 0.3s ease';
        
        this.messageEl = contentEl.createEl('p', { 
            text: 'Starting...',
            cls: 'progress-message'
        });
        this.messageEl.style.textAlign = 'center';
        this.messageEl.style.color = 'var(--text-muted)';
        this.messageEl.style.margin = '10px 0';
    }

    setTitle(title: string) {
        if (this.titleEl) {
            this.titleEl.textContent = title;
        }
    }

    setProgress(percent: number, message: string) {
        if (this.progressEl) {
            this.progressEl.style.width = \`\${Math.min(100, Math.max(0, percent))}%\`;
        }
        if (this.messageEl) {
            this.messageEl.textContent = message;
        }
    }

    onClose() {
        this.contentEl.empty();
    }
}

/**
 * Interface for spell check corrections
 */
export interface Correction {
    issueIndex: number;
    start: number;
    end: number;
    replacement: string;
}`
        };

        function downloadPlugin() {
            /* Create a zip-like structure by downloading individual files */
            const files = Object.entries(pluginFiles);
            
            files.forEach(([filename, content]) => {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            new Notice('Plugin files downloaded! Extract to your Obsidian plugins folder.');
        }

        function viewDocumentation() {
            const docContent = `# Perplexity Vault Assistant Documentation

## Installation

1. Download all plugin files
2. Create folder: \`.obsidian/plugins/perplexity-vault-assistant/\`
3. Place all files in the folder
4. Enable plugin in Obsidian settings
5. Configure your Perplexity API key

## Features

### Vault Analysis
- Analyzes entire vault structure
- Identifies common topics and themes
- Creates content map for better organization

### Spell Checking
- Markdown-aware spell checking
- Ignores code blocks, links, and formatting
- Custom dictionary support
- Batch processing capabilities

### Smart Linking
- AI-powered semantic analysis
- Finds related content automatically
- Suggests meaningful connections
- Respects existing link structure

## Commands

- \`Analyze entire vault\`: Full vault analysis
- \`Spell check current file\`: Check active file
- \`Spell check all files\`: Batch spell check
- \`Format current file\`: Clean markdown formatting
- \`Generate smart links\`: AI-powered link suggestions

## Settings

- **API Key**: Your Perplexity API key
- **Language**: Spell check language
- **Auto Format**: Format while spell checking
- **Smart Linking**: Enable AI link suggestions
- **Cache Duration**: How long to cache results
- **Batch Size**: Files per processing batch

## API Usage

This plugin uses the Perplexity API for advanced features:
- Content analysis and topic extraction
- Semantic similarity calculations
- Advanced spell checking and grammar
- Intelligent content understanding

## Development

Built with TypeScript and follows Obsidian plugin architecture:
- Main plugin class extends Plugin
- Modular component design
- Proper error handling
- Performance optimization
- User-friendly interface`;
            
            const blob = new Blob([docContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'README.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add a simple notice system
        function Notice(message) {
            const notice = document.createElement('div');
            notice.textContent = message;
            notice.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--color-primary);
                color: var(--color-btn-primary-text);
                padding: 12px 16px;
                border-radius: 6px;
                z-index: 1000;
                box-shadow: var(--shadow-lg);
                max-width: 300px;
            `;
            
            document.body.appendChild(notice);
            
            setTimeout(() => {
                if (notice.parentNode) {
                    notice.parentNode.removeChild(notice);
                }
            }, 3000);
        }
        
        // Make Notice available globally
        window.Notice = Notice;
    </script>
</body>
</html>